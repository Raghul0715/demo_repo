name: Package selected ADF assets -> JFrog (parameterized, Windows)

on:
  workflow_dispatch:
    inputs:
      artifact_basename:
        description: 'Artifact base name (used to name ZIP). e.g. D365-CustomerCare-ADF'
        required: true
        default: 'D365-CustomerCare-ADF'
      pipeline_file:
        description: 'Repo relative path to pipeline (e.g. pipeline/CRM_Sync_ProcedureCode.json). Leave empty to skip.'
        required: false
        default: ''
      dataset_file:
        description: 'Repo relative path to dataset (e.g. dataset/DS_SomeDataset.json). Leave empty to skip.'
        required: false
        default: ''
      linkedservice_file:
        description: 'Repo relative path to linkedService (e.g. linkedService/LS_Sql.json). Leave empty to skip.'
        required: false
        default: ''
      dataflow_file:
        description: 'Repo relative path to dataflow (e.g. dataflow/DF_Transform.json). Leave empty to skip.'
        required: false
        default: ''

# Keep the same env variable names/format you used in your working yml
env:
  PkgBase: "D365-CustomerCare-ADF"
  ArtifactoryRepoName: "workflow-zip-D365-np-deploy"
  ArtifactReleaseDir: "${{ github.workspace }}\\ReleasePackages"
  Art_PE_URL: "https://caresource.pe.jfrog.io"
  JFROG_CLI_HOME_DIR: "${{ github.workspace }}\\jfrog"

jobs:
  build_and_package:
    # windows runner same as your original workflows
    runs-on:
      group: caresource-windows-default
      labels: bld06

    outputs:
      zipname: ${{ steps.makezip.outputs.zipname }}

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare workspace (Windows)
        run: |
          if (Test-Path -Path "${{ env.ArtifactReleaseDir }}" ) { Remove-Item -Recurse -Force "${{ env.ArtifactReleaseDir }}" }
          New-Item -ItemType Directory -Force -Path "${{ env.ArtifactReleaseDir }}" | Out-Null
          if (Test-Path -Path "${{ github.workspace }}\package_work") { Remove-Item -Recurse -Force "${{ github.workspace }}\package_work" }
        shell: pwsh

      - name: Copy user-selected files into package structure
        id: copy
        run: |
          $base = "${{ github.workspace }}\package_work"
          $found=0

          function Copy-IfProvided([string]$inputVar, [string]$targetDir) {
            if ($inputVar -and $inputVar.Trim() -ne "") {
              $src = Join-Path -Path "${{ github.workspace }}" -ChildPath $inputVar
              if (Test-Path -Path $src -PathType Leaf) {
                Write-Host "Creating folder: $targetDir"
                New-Item -ItemType Directory -Force -Path (Join-Path $base $targetDir) | Out-Null
                Copy-Item -Path $src -Destination (Join-Path $base $targetDir) -Force
                Write-Host "Copied: $src -> $($base)\$targetDir"
                $script:found = 1
              } else {
                Write-Host "File not found in repo (skipping): $src"
              }
            } else {
              Write-Host "No input specified for $targetDir - skipping"
            }
          }

          # Inputs from the workflow_dispatch
          $pipeline_in = '${{ github.event.inputs.pipeline_file }}'
          $dataset_in = '${{ github.event.inputs.dataset_file }}'
          $linked_in  = '${{ github.event.inputs.linkedservice_file }}'
          $dataflow_in = '${{ github.event.inputs.dataflow_file }}'

          Copy-IfProvided $pipeline_in 'pipeline'
          Copy-IfProvided $dataset_in 'dataset'
          Copy-IfProvided $linked_in  'linkedService'
          Copy-IfProvided $dataflow_in 'dataflow'

          if ($script:found -ne 1) {
            Write-Host "No files were copied. Will create a placeholder file to avoid empty zip."
            New-Item -ItemType Directory -Force -Path $base | Out-Null
            "placeholder" | Out-File -FilePath (Join-Path $base "placeholder.txt") -Encoding utf8
          }

          Write-Host "Package_work contents:"
          Get-ChildItem -Recurse -Force "$base" | ForEach-Object { Write-Host $_.FullName }

          # expose a flag output for later if required
          Echo "::set-output name=copied::$($script:found)"

        shell: pwsh

      - name: Create ZIP package (Windows)
        id: makezip
        run: |
          $artifactBase = '${{ github.event.inputs.artifact_basename }}'
          $runNum = $env:GITHUB_RUN_NUMBER
          $zipname = "${artifactBase}-${runNum}.zip"
          $releaseDir = "${{ env.ArtifactReleaseDir }}"
          if (!(Test-Path -Path $releaseDir)) { New-Item -ItemType Directory -Force -Path $releaseDir | Out-Null }

          $sourceDir = "${{ github.workspace }}\package_work"

          Write-Host "Creating zip $zipname from $sourceDir -> $releaseDir"
          # Ensure the compress-archive overwrites if exists
          $targetPath = Join-Path $releaseDir $zipname

          if (Test-Path $targetPath) { Remove-Item -Force $targetPath }

          # Compress-Archive will error if sourceDir empty; but we ensured placeholder if nothing copied
          Compress-Archive -Path (Join-Path $sourceDir '*') -DestinationPath $targetPath -Force

          Write-Host "Created $targetPath"
          Get-ChildItem -Path $releaseDir | ForEach-Object { Write-Host $_.FullName }

          # Set output for other jobs
          Write-Output "::set-output name=zipname::$zipname"
        shell: pwsh

  # artifactory_upload job (replace your existing artifactory_upload job with this)
artifactory_upload:
  name: Artifactory Upload
  runs-on: ubuntu-latest            # <-- use Ubuntu for upload step
  needs: build_and_package
  env:
    PkgBase: "${{ env.PkgBase }}"
    ARTIFACT_BUILD_NUMBER: "${{ needs.build_and_package.outputs.ARTIFACT_BUILD_NUMBER }}"   # if you set this output
    ArtifactoryRepoName: "${{ env.ArtifactoryRepoName }}"   # repo/path in Artifactory (e.g. workflow-zip-D365-np-deploy)
    RepoName: "${{ env.RepoName }}"                         # sub-folder/repo name you used earlier
    ArtifactReleaseDir: "${{ env.ArtifactReleaseDir }}"     # where the build created the zip
    ArtProjectKey: "${{ env.ArtProjectKey }}"
    Art_PE_URL: "${{ env.Art_PE_URL }}"
    JFROG_CLI_HOME_DIR: "${{ env.JFROG_CLI_HOME_DIR }}"
  steps:
    - name: Download build artifact
      uses: actions/download-artifact@v4
      with:
        name: build-zip
        path: ${{ env.ArtifactReleaseDir }}   # download into the same folder path you used in build

    - name: Setup JFrog CLI
      uses: jfrog/setup-jfrog-cli@v4.2.2
      env:
        JFROG_CLI_HOME_DIR: ${{ env.JFROG_CLI_HOME_DIR }}

    - name: Configure JFrog CLI
      run: |
        # configure jfrog CLI using access token in secrets
        jf c add --url="${{ env.Art_PE_URL }}" --access-token="${{ secrets.JF_SAAS_TOKEN }}" --interactive=false artifactory-saas
        jf c show artifactory-saas

    - name: Upload to Artifactory (Main or Release)
      run: |
        # zipname comes from build job output - keep same reference as your build
        ZIPNAME="${{ needs.build_and_package.outputs.zipname }}"
        echo "Uploading ${ZIPNAME} to Artifactory repo ${ArtifactoryRepoName}/${RepoName}/"

        # upload (same flags/format you used before)
        jf rt upload "ReleasePackages/${ZIPNAME}" "${ArtifactoryRepoName}/${RepoName}/" --flat=true --build-name="${PkgBase}" --build-number="${{ github.run_number }}" --server-id=artifactory-saas

        # optionally mark the build (same as your original)
        jf rt bp "${PkgBase}" "${{ github.run_number }}" --server-id=artifactory-saas
